## 任务

某个机器的配置为：CPU 8 cores, MEM 4G, HDD 4T。

这个机器上有一个 1T 的无序数据文件，格式为 (key_size, key, value_size, value)，所有 key 都不相同。

设计一个索引结构，使得并发随机地读取每一个 key-value 的代价最小；读取时 key 必然在文件中且大致符合齐夫分布。

允许对数据文件做任意预处理，但是预处理的时间计入到整个读取过程的代价里。

key 和 value 的大小符合 uniform 分布。

## 思路

每个key必定存在，所以不需要建立布隆过滤器。

常见的索引有hash索引和B+Tree索引。

对于这个场景，特点是数据量大、无序和key/value大小均不确定（无schema）。

使用B+Tree仅需索引时，由于无序会频繁的分裂节点，磁盘写入次数和写入量均较多。数据没有schema，key/value大小不确定，则另需要引入对大字段的优化。

B+Tree索引的优点是索引建立完成之后，对后续的读写友好。支持范围查询。缺点则是预处理工作繁重。

出于简单起见选择了hash索引。由于读取分布符合齐夫分布，所以需要加入缓存。

hash索引的优点是预处理简单。缺点则是平均每次查询的磁盘IO数较大。

## 设计
每个Entry包含相应hash值在文件中的偏移量，如果不符合该偏移量处的key，则根据next找到下一个Entry。再进行比较。每个Entry占用16Byte
```c
struct Entry {
  uint64_t offset;
  uint64_t next;
};
```

hash桶存储冲突链表的首部，每个bucket占用8字节，整个桶占用1GiB空间。共128M个slot。
剩余空间是冲突链表。

所以当kv的数量大于128M个时，每次查询都需要2次以上的寻址。

建立索引需要遍历一遍原始数据。主线程找出每个 kv 的起始位置的偏移量，加入任务队列。其余线程获取到偏移量后根据hash函数找到对应的桶，加入到冲突链表首部。使用CAS（不过性能瓶颈应该在磁盘IO上，无锁带来的收益可能并不多）。

当建立完索引之后在内存中建立缓存，使用LRU算法。保存最近访问过的数据。

